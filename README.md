# dns-channel

A possibly **simple** and **efficient** toolkit to perform DNS, powered with the DNS engine by [Luchini & Quadrio, J. Comp. Phys. (2006)](http://www.sciencedirect.com/science/article/pii/S0021999105002871)


## Calculating and plotting spectra

The first step for plotting a spectrum consists in calculating them. This is done with the _psd_ utility in folder _spectra_. Suppose that the output of your simulation is contained in folder `~/sim_output` and this code is in folder `/path/to/dns_channel`; to calculate spectra, one needs to run the following in the terminal:
``` shell
~$  cd sim_output
~/sim_output$   /path/to/dns_channel/spectra/psd 1 1 localhost start_field end_field step_field
```
where `start_field` and `end_field` are the first and last of the list of fields used for postprocessing; `step_field` indicates the step between the numbering of fields in the list. For instance, `2 8 3` will pick fields 2, 5, 8. The output of this process is a binary file `psd.bin` containing the spectra, located in the same folder `~/sim_output`; this binary file can be read from some Python modules included in this repository. To begin with, one should create a Python script (here called for instance `scriptra.py`) in the same folder:
``` shell
~/sim_output$   touch scriptra.py
```
then one should import the module `dns_channel.spectra`, which is assumed to be in the Python path for the current user. Function `read_psd` takes as input the folder containing `psd.bin` (here, the current folder `'.//'`, as the script will be run from here); it returns spectra as a numpy array (`all_spectra`), the arrays of kx and kz wavenumbers and the array of y coordinates. The content of `all_spectra` can be then plotted; in the following example, we use function `plot_cumulative_zy`:
```python
from dns_channel.spectra import *
import matplotlib.pyplot as plt

all_spectra, kx, kz, y = read_psd('.//')
fig,ax = plot_cumulative_zy(all_spectra, 'x', y, kz, save_fig=True, save_size=(0.83333333,0.57267))
```
This functions plots the cumulative (one-dimensional) spectrum in the z direction; its inputs are:
- the array `all_spectra` generated by `read_psd`
- a string indicating the component (`'x'` in this case); one can either provide the axis name (as it has been done here) or can specify the components with two letters, as in `'uu'` (which is equivalent to `'x'`) or `'uv'`
- the array of y coordinates `y` generated by `read_psd`
- the array of kz modes `kz` generated by `read_psd`
- `save_fig` is an optional flag defaulted to false; if true, both a png containing the image without axes and the `.tikz` code to generate a proper pdf image are saved; this need to be compiled, say, with `pdflatex`
- `save_size` is also optional and defaults to `(1,1)`; it specifies the size of the saved figure relative to `\linewidth`
- an additional optional argument `y_simm` is present (here it is not specified, hence it defaults to true); if true, zooms the picture on the half channel

The function returns two handles 'fig, ax' to the generated plot. Other functions are available for plotting, namely:
- `plot_premultiplied(all_spectra, component, desired_y, y, kx, kz)` plots the premultiplied spectra at y position `desired_y`
- `plot(all_spectra, component, desired_y, y, kx, kz)` plots the spectrum without premultiplication
- `plot_cumulative_xy(all_spectra, component, y, kx)` plots the cumulative (one-dimensional) spectrum in the x direction

Finally, the script can be executed as:
``` shell
~/sim_output$   python scriptra.py
```
This plots the spectra on the screen; moreover, since we asked to save the figure, two files `uu_cumulative_zy.tikz` and `uu_cumulative_zy.png` are created in folder `~/sim_output`; name vary depending on function used and component chosen. A pdf file containing the full image can be generated as:
``` shell
~/sim_output$   pdflatex uu_cumulative_zy.tikz
```
Alternatively, one can modify the output `.tikz` file by hand before compiling.



## Changelog

_As a general rule, all of the budget terms calculated by_ uiuj _and_ uiuj_largesmall _have such a sign that, by_ __summing__ _all of them together, one gets 0 (or the residual, more realistically)._ __This is yet to be fixed on other executables (uiuj_ow, uiuj_spectra, possibly read_uiuj).__

Fixes in old _uiuj_ and _uiuj2ascii_ modules:
- tke and its budget are now the trace of the Reynolds stress tensor __already divided by 2__ (as they should be)
- the sign of dissipation has been corrected, so that by summing all the profiles one gets zero (which is, dissipation is now negative for tke and positive for $\langle uv \rangle$ )
- the same treatment in terms of sign has been applied to the mke budget
- every file output by _uiuj2ascii_ now has a header of 1 line which specifies which fields have been used to calculate statistics
- syntax is now:
``` bash
/path/to/exec/uiuj 1 1 localhost start_field end_field step_field
```

Added a module _uiuj_largesmall_ that computes the budget for the large-scale and small-scale fluctuation fields:

- large-small decomposition is defined in `largesmall_def.cpl`; this also refers to a file `largesmall_settings.in` that should be put in the working directory with the fields being postprocessed
- `uiuj_largesmall.cpl` calculates the budget, with the same syntax as _uiuj_
- `uiuj_largesmall2ascii.cpl` converts it to ascii; as for _uiuj2ascii_, a one-line header is included specifying the fields used to calculate average

Added Python scripts to:

- calculate the energy box, with both extended Reynolds decomposition and large/small decomposition
- read the output of _uiuj_ as well as of `dns.in`

